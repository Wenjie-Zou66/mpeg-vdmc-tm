/* The copyright in this software is being made available under the BSD
 * License, included below. This software may be subject to other third party
 * and contributor rights, including patent rights, and no such rights are
 * granted under this license.
 *
 * Copyright (c) 2023, ISO/IEC
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *  * Neither the name of the ISO/IEC nor the names of its contributors may
 *    be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _EB_BASIC_ENCODER_H_
#define _EB_BASIC_ENCODER_H_

#include <fstream>
#include <stack>

// internal headers
#include "ebModel.h"
#include "ebCTMesh.h"
#include "ebEncoder.h"
#include "ebBitstream.h"

namespace eb {

    class EBBasicEncoder: public EBEncoder {

    public: // methods

        EBBasicEncoder() {};

        virtual void encode(const Model& input);
        virtual bool serialize(Bitstream& bitstream);
        virtual bool save(std::string fileName);

    private:

        // Internal options

        // preprocessing data
        std::vector<int> dummyVertices;

        // Variables for storing Input OVTable and geometry
        
        std::vector<glm::vec3> G_est;		  // Input Geometry estimates

        int numOfVertices  = 0;
        int numOfTriangles = 0;
        int numOfUVCoords  = 0;

        // Compression variables
        int N;    					               // vertex count
        int T;    					               // triangles count
        std::vector<int> M;	               // Vertex marking array
        std::vector<int> MI;               // Vertex indexing (use the marking with beyond 0/1)
        std::vector<int> U;	               // Triangles marking array
        std::vector<int> UF;	           // Triangles marking array for FaceID encoding (could reuse U)
        std::vector<int> MC;               // Corners marking array
        int ccCount = 0;                   // index of current CC, number of CCs at the end

        // EB output data storage before Arithmetic Coding
        std::vector<char> oClers;
        std::vector<int> oHandles;          // handle corners array
        std::vector<int> oHandleSizes;      // handle corners non null array sizes
        std::vector<glm::vec3> oVertices;   // contains positions or deltas
        std::vector<glm::vec2> oUVCoords;   // contains positions or deltas
        std::vector<glm::vec3> sVertices;   // contains positions of start or dummy positions
        std::vector<glm::vec2> sUVCoords;   // contains positions or start or dummy uv coords
        std::vector<int> oFids;             // contains the face id sequence
        std::vector<int>  oNotPredictedFaceId;   // contains non predicted face id sequence
        std::vector<bool> oFidsIdIsDifferent;    // contains face id Difference boolean sequence
        std::vector<bool> oFaceIdIsRight;        // contains face id Right prediction boolean sequence
        std::vector<bool> oFaceIdIsLeft;         // contains face id Left prediction boolean sequence
        std::vector<bool> oFaceIdIsFacing;       // contains face id Facing prediction boolean sequence
        int prevFaceId = -1;                     // contains the previously travered face id value

        std::vector<int> oDummies;          // indices of artificially inserted vertices
        std::vector<bool> orientations;
        std::vector<bool> seams;            // for separate uv indices table generation
        std::vector<int> processedCorners;  // corners in their order of visit by edgebreaker
        std::vector<int> ccStartCorners;    // CC stat corners in their order of visit by edgebreaker
        std::vector<int> ccProcessedEndIdx; // end index of processedCorner per CC, in their order of visit by edgebreaker

        std::vector<int> oDuplicateSplitVertexIdx;  // from which unique split vertex is the duplicated point originating added
        std::vector<bool> oDuplicatesOnStart;       // are duplicates inserted as the first 2 vertices of the first triangle of a connected component
        std::set<int> processedDupIdx;
        std::vector<bool> isVertexDup;
        int posSkipDup = 0;                         // number of duplicates for which position is not predicted - nb added vertices in the end

        // start compression for corner c
        void startCompression(const int c);
        // compress the CC
        void CompressRec(int c);
        void CheckHandle(const int c);
        // encodes attributes of corner c, only those using main index table, v in [0,1,2,-1] = [start, delta1, delta2, para]
        void encodeMainIndexAttributes(const int c, const int v);
        // encodes all the attributes of the cc that uses the main index table
        void encodeCcMainIndexAttributes(const int startCorner);
        // encodes all the attributes that uses a separate index table, of all the corners
        void encodeSeparateIndexAttributes(void);// const int startCorner);
        // encodes the per face attributes
        void encodePerFaceAttributes(void);

        void posEncodeWithPrediction(const int c, const int v);
        // use min stretch to predict uv
        void predictUV(const int c, glm::vec2& predUV, const std::vector<int>& indices);
        // encode Uv using main index
        void uvEncodeWithPrediction(const int c, const int v);
        // encode Uv using separate index
        void uvSepEncodeWithPrediction(const int c);
        
        // helper function
        inline bool isVertexDummy(const int v)
        {
            return ((dummyVertices.size() > 0) && (v >= dummyVertices[0]));
        }

        inline bool isCornerVertexDummy(const int c)
        {
            return isVertexDummy( _ovTable.V[c] );
        }

        inline bool isCornerFaceDummy(const int c)
        {
            return isVertexDummy(_ovTable.V[c]) || isVertexDummy(_ovTable.V[_ovTable.n(c)]) || isVertexDummy(_ovTable.V[_ovTable.p(c)]);
        }

    };

};  // namespace mm

#endif
